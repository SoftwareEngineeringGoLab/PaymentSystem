# فاز ۱ – گزارش کد اسمِل‌ها و نقض اصول SOLID

## مقدمه
## اصول SOLID در طراحی شی‌گرا

اصول SOLID پنج اصل کلیدی در طراحی نرم‌افزار شی‌گرا هستند که هدف آن‌ها ایجاد کدی قابل نگهداری، توسعه‌پذیر، و خوانا است. این اصول عبارت‌اند از:

- **S: اصل مسئولیت یگانه (Single Responsibility Principle)** – هر کلاس باید تنها یک مسئولیت داشته باشد و فقط به یک دلیل تغییر کند.
- **O: اصل باز-بسته بودن (Open/Closed Principle)** – کلاس‌ها باید برای توسعه باز و برای تغییر بسته باشند، یعنی بتوانیم بدون تغییر در کد موجود، ویژگی جدید اضافه کنیم.
- **L: اصل جایگزینی لیسکوف (Liskov Substitution Principle)** – کلاس‌های فرزند باید بتوانند جایگزین کلاس‌های والد خود شوند بدون اینکه رفتار سیستم را خراب کنند.
- **I: اصل تفکیک واسط‌ها (Interface Segregation Principle)** – نباید کلاس‌ها را مجبور کنیم متدهایی را پیاده‌سازی کنند که به آن‌ها نیازی ندارند؛ واسط‌ها باید کوچک و اختصاصی باشند.
- **D: اصل وارونگی وابستگی (Dependency Inversion Principle)** – ماژول‌های سطح بالا نباید مستقیماً به ماژول‌های سطح پایین وابسته باشند؛ هر دو باید به انتزاع‌ها وابسته باشند.

---

## مشکلات کد (Code Smells)

1. **کلاس بزرگ با وظایف متعدد**  
   کلاس `PaymentProcessor` هم‌زمان مسئول ولیدیشن، پردازش پرداخت و لاگینگ است.

2. **سوئیچ‌های بزرگ**  
   متدهای `processPayment` و `validatePayment` از سوئیچ بر اساس نوع پرداخت استفاده می‌کنند و افزودن روش جدید را دشوار می‌سازند.

3. **مقادیر ثابت و رشته‌های جادویی**  
   ارزها (`"USD"`, `"EUR"`, `"GBP"`) و کلیدهایی مثل `"card_number"`، `"wallet_id"` و ... در کد به صورت هاردکد قرار داده شده‌اند.

4. **متدهای چندمنظوره**  
   متدی مانند `processPayment` هم‌زمان ولیدیشن، پردازش و لاگینگ را انجام می‌دهد که اصل تک‌وظیفگی را زیر سؤال می‌برد.

---

## نقض اصول SOLID

### 1. اصل Single Responsibility (SRP)
  - کلاس `PaymentProcessor` علاوه بر مسئولیت پردازش پرداخت (Process Payment)، وظایف مختلف دیگری مانند لاگینگ (Log Transaction) و ولیدیشن (Validate Payment) را نیز بر عهده دارد. این باعث می‌شود تغییر در یکی از این وظایف روی کل کلاس اثر بگذارد و پیچیدگی را افزایش دهد.

### 2. اصل Open-Closed (OCP)
  - در متدهای `processPayment` و `validatePayment` از سوئیچ برای نوع پرداخت استفاده می‌شود. اگر قرار باشد روش پرداخت جدید (مثلاً پرداخت با کریپتو) اضافه کنیم، مجبور هستیم این متدها را تغییر دهیم. بنابراین، کلاس برای اضافه شدن ویژگی‌های جدید **باز** است اما باید **تغییر** داده شود که خلاف OCP است.

### 3. اصل Interface Segregation (ISP)
  - در این کد، عملاً اینترفیس رسمی وجود ندارد، ولی اگر بخواهید اینترفیس واحدی برای تمام انواع پرداخت تعریف کنید که متدهای مخصوص به هر پرداخت (Credit Card, Wallet, Bank Transfer) را در بر داشته باشد، کلاس‌هایی که به برخی متدها نیازی ندارند، بی‌دلیل مجبور به پیاده‌سازی خواهند شد. این نقض ISP است. با تعریف اینترفیس‌های جداگانه برای هر نوع پرداخت (یا دست‌کم تفکیک رفتارها) می‌توان آن را رفع کرد.

### 4. اصل Dependency Inversion (DIP)
  - در کد فعلی، کلاس `PaymentProcessor` به‌صورت مستقیم با جزییات پیاده‌سازی ماژول‌های سطح پایین مانند APIهای کارت اعتباری، والت دیجیتال و بانک ترنسفر کار می‌کند. این موضوع در متدهایی مانند `processCreditCard`، `processDigitalWallet` و `processBankTransfer` دیده می‌شود، جایی که آدرس‌های API به‌صورت هاردکد شده از `config` خوانده می‌شوند و پردازش پرداخت نیز به‌طور مستقیم در همان کلاس انجام می‌شود. به‌جای اینکه کلاس اصلی به یک اینترفیس یا ماژول انتزاعی وابسته باشد، مستقیماً به پیاده‌سازی‌های خاص وابسته است. این امر باعث می‌شود تغییر در هر نوع پرداخت یا جایگزینی یک API جدید، نیاز به تغییر در کلاس `PaymentProcessor` داشته باشد، که خلاف اصل DIP است. راه‌حل مناسب، تعریف یک اینترفیس مانند `PaymentGateway` و تزریق وابستگی از بیرون است تا کلاس سطح بالا تنها به انتزاع وابسته باشد، نه به پیاده‌سازی خاص.


