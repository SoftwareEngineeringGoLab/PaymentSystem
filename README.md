# فاز ۱ – گزارش کد اسمِل‌ها و نقض اصول SOLID

## مقدمه
## اصول SOLID در طراحی شی‌گرا

اصول SOLID پنج اصل کلیدی در طراحی نرم‌افزار شی‌گرا هستند که هدف آن‌ها ایجاد کدی قابل نگهداری، توسعه‌پذیر، و خوانا است. این اصول عبارت‌اند از:

- **S: اصل مسئولیت یگانه (Single Responsibility Principle)** – هر کلاس باید تنها یک مسئولیت داشته باشد و فقط به یک دلیل تغییر کند.
- **O: اصل باز-بسته بودن (Open/Closed Principle)** – کلاس‌ها باید برای توسعه باز و برای تغییر بسته باشند، یعنی بتوانیم بدون تغییر در کد موجود، ویژگی جدید اضافه کنیم.
- **L: اصل جایگزینی لیسکوف (Liskov Substitution Principle)** – کلاس‌های فرزند باید بتوانند جایگزین کلاس‌های والد خود شوند بدون اینکه رفتار سیستم را خراب کنند.
- **I: اصل تفکیک واسط‌ها (Interface Segregation Principle)** – نباید کلاس‌ها را مجبور کنیم متدهایی را پیاده‌سازی کنند که به آن‌ها نیازی ندارند؛ واسط‌ها باید کوچک و اختصاصی باشند.
- **D: اصل وارونگی وابستگی (Dependency Inversion Principle)** – ماژول‌های سطح بالا نباید مستقیماً به ماژول‌های سطح پایین وابسته باشند؛ هر دو باید به انتزاع‌ها وابسته باشند.

---

## مشکلات کد (Code Smells)

1. **کلاس بزرگ با وظایف متعدد**  
   کلاس `PaymentProcessor` هم‌زمان مسئول ولیدیشن، پردازش پرداخت و لاگینگ است.

2. **سوئیچ‌های بزرگ**  
   متدهای `processPayment` و `validatePayment` از سوئیچ بر اساس نوع پرداخت استفاده می‌کنند و افزودن روش جدید را دشوار می‌سازند.

3. **مقادیر ثابت و رشته‌های جادویی**  
   ارزها (`"USD"`, `"EUR"`, `"GBP"`) و کلیدهایی مثل `"card_number"`، `"wallet_id"` و ... در کد به صورت هاردکد قرار داده شده‌اند.

4. **متدهای چندمنظوره**  
   متدی مانند `processPayment` هم‌زمان ولیدیشن، پردازش و لاگینگ را انجام می‌دهد که اصل تک‌وظیفگی را زیر سؤال می‌برد.

---

## نقض اصول SOLID

### 1. اصل Single Responsibility (SRP)
کلاس `PaymentProcessor` علاوه بر مسئولیت اصلی پردازش پرداخت، وظایف دیگری نظیر لاگینگ و اعتبارسنجی را نیز بر عهده دارد. این مسئله باعث می‌شود هر تغییری در یکی از این وظایف بر کل کلاس اثر بگذارد و پیچیدگی و هزینه‌ی نگهداری را بالا ببرد.

### 2. اصل Open-Closed (OCP)
در متدهای `processPayment` و `validatePayment`، برای تشخیص نوع پرداخت از ساختار سوئیچ استفاده شده است. برای افزودن یک روش پرداخت جدید (مثلاً پرداخت با ارز دیجیتال)، باید این متدها را ویرایش کرد. این بدان معناست که کلاس برای افزودن ویژگی جدید **باز** است اما نیازمند **تغییر** در کد فعلی است که مغایر با اصل OCP می‌باشد.

### 3. اصل Interface Segregation (ISP)
در این کد Interface  تعریف نشده است. اگر بخواهیم یک اینترفیس واحد بسازیم که متدهای انواع پرداخت (کارت اعتباری، کیف پول دیجیتال و انتقال بانکی) را در بر داشته باشد، کلاس‌هایی که تنها بخشی از این متدها را نیاز دارند، بیهوده ملزم به پیاده‌سازی سایر متدها خواهند شد. این کار با اصل ISP در تضاد است. راهکار آن، تعریف اینترفیس‌های مجزا برای هر نوع پرداخت یا حداقل تفکیک رفتارهاست.

### 4. اصل Dependency Inversion (DIP)
کلاس `PaymentProcessor` به‌صورت مستقیم با جزییات ماژول‌های سطح پایین همچون APIهای کارت اعتباری، کیف پول دیجیتال و انتقال بانکی کار می‌کند (در متدهایی مانند `processCreditCard`، `processDigitalWallet` و `processBankTransfer`). 

### 5. اصل Liskov Substitution (LSP)
در نمونه کد داشده شده نقض این قانون مشاهده نمی شود.


# مستندات فاز دوم 

1. **ایجاد کلاس انتزاعی Payment با ویژگی‌های مشترک**  
   - کلاس `Payment` سه ویژگی اصلی دارد: `amount`, `currency`, و `timeOfEntry`.  
   - یک متد انتزاعی `validatePayment()` تعریف شده که زیرکلاس‌ها باید آن را پیاده‌سازی کنند.

2. **توسعه‌ی زیرکلاس‌ها با متد `validatePayment()` اختصاصی**  
   - سه زیرکلاس ساخته شده‌اند: `CreditCardPayment`, `DigitalWalletPayment`, `BankTransferPayment`.  
   - هرکدام در متد `validatePayment()` منطق خاص خود را پیاده‌سازی می‌کند (مثلاً بررسی شماره کارت یا شناسه‌ی کیف دیجیتال).

3. **تفکیک منطق پردازش پرداخت از ارتباط با سرویس‌های خارجی**  
   - کلاس `PaymentProcessor` مسئول ایجاد پرداخت، اعتبارسنجی و مدیریت گردش کار است.  
   - کلاس `PaymentGateway` تنها برای ارتباط با سرویس‌های خارجی (APIها) استفاده می‌شود و درگاه‌های مختلف را پردازش می‌کند.  
   - این جداسازی باعث می‌شود منطق تجاری (پردازش) و یکپارچه‌سازی با سرویس خارجی (Gateways) در بخش‌های مجزا نگهداری شوند.

با انجام این موارد، اهداف مرحله‌ی دوم محقق شده است.
